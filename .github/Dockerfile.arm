# Dockerfile for building Kindle HID Passthrough ARM binary
# Uses Nuitka with special ARM flags to handle branch range issues
# Target: ARMv7 hard-float (armhf)

# Use Debian-based image - Kindle uses glibc, not musl
FROM arm32v7/python:3.11-slim-bookworm

# Install build dependencies including Rust for some Python packages
RUN apt-get update && apt-get install -y --no-install-recommends \
    build-essential \
    patchelf \
    ccache \
    libffi-dev \
    zlib1g-dev \
    linux-libc-dev \
    libssl-dev \
    rustc \
    cargo \
    && rm -rf /var/lib/apt/lists/*

# Install Python build tools and dependencies
RUN pip install --no-cache-dir \
    nuitka \
    ordered-set \
    zstandard \
    bumble>=0.0.193 \
    aiofiles>=23.0.0

# Enable ccache for faster C compilation
ENV CCACHE_DIR=/ccache
ENV PATH="/usr/lib/ccache:${PATH}"

WORKDIR /build

# Copy source files
COPY kindle_hid_passthrough/*.py /build/kindle_hid_passthrough/
COPY kindle_hid_passthrough/config.ini /build/kindle_hid_passthrough/

# ARM-specific compiler flags to fix branch range errors:
# -mword-relocations: Use word-sized relocations for position-independent code
# -mlong-calls: Generate long call sequences for distant functions
# -ffunction-sections -fdata-sections: Enable linker garbage collection
ENV CFLAGS="-mword-relocations -mlong-calls -ffunction-sections -fdata-sections"
ENV LDFLAGS="-Wl,--gc-sections"

# Build syscall wrapper library for Kindle kernel compatibility
# Kindle kernel 4.9.77 is missing pwritev2/preadv2 syscalls
RUN printf '%s\n' \
    '#define _GNU_SOURCE' \
    '#include <sys/uio.h>' \
    '#include <unistd.h>' \
    '' \
    'ssize_t preadv2(int fd, const struct iovec *iov, int iovcnt, off_t offset, int flags) {' \
    '    return preadv(fd, iov, iovcnt, offset);' \
    '}' \
    '' \
    'ssize_t pwritev2(int fd, const struct iovec *iov, int iovcnt, off_t offset, int flags) {' \
    '    return pwritev(fd, iov, iovcnt, offset);' \
    '}' \
    > /build/syscall_wrapper.c && \
    gcc -shared -fPIC -o /build/libsyscall_wrapper.so /build/syscall_wrapper.c && \
    strip /build/libsyscall_wrapper.so

# Build with Nuitka
# ARM compiler flags handle branch range issues for large modules like bumble.hci
RUN python3 -m nuitka \
    --mode=onefile \
    --jobs=$(nproc) \
    --lto=no \
    --low-memory \
    --show-progress \
    --output-filename=kindle-hid-passthrough.bin \
    --include-package=kindle_hid_passthrough \
    --include-data-file=kindle_hid_passthrough/config.ini=kindle_hid_passthrough/config.ini \
    --nofollow-import-to=pytest \
    --nofollow-import-to=unittest \
    --nofollow-import-to=setuptools \
    kindle_hid_passthrough/main.py

# Build C wrapper that sets up LD_PRELOAD and execs the real binary
# This eliminates the need for run.sh
RUN printf '%s\n' \
    '#define _GNU_SOURCE' \
    '#include <stdio.h>' \
    '#include <stdlib.h>' \
    '#include <string.h>' \
    '#include <unistd.h>' \
    '#include <libgen.h>' \
    '#include <linux/limits.h>' \
    '' \
    'int main(int argc, char *argv[]) {' \
    '    char exe_path[PATH_MAX];' \
    '    char dir_path[PATH_MAX];' \
    '    char bin_path[PATH_MAX];' \
    '    char lib_path[PATH_MAX];' \
    '    ssize_t len;' \
    '' \
    '    /* Get path to this executable */' \
    '    len = readlink("/proc/self/exe", exe_path, sizeof(exe_path) - 1);' \
    '    if (len == -1) {' \
    '        perror("readlink");' \
    '        return 1;' \
    '    }' \
    '    exe_path[len] = '"'"'\0'"'"';' \
    '' \
    '    /* Get directory */' \
    '    strncpy(dir_path, exe_path, sizeof(dir_path));' \
    '    char *dir = dirname(dir_path);' \
    '' \
    '    /* Build paths */' \
    '    snprintf(bin_path, sizeof(bin_path), "%s/kindle-hid-passthrough.bin", dir);' \
    '    snprintf(lib_path, sizeof(lib_path), "%s/libsyscall_wrapper.so", dir);' \
    '' \
    '    /* Set environment */' \
    '    setenv("LD_PRELOAD", lib_path, 1);' \
    '    setenv("KINDLE_HID_BASE", dir, 1);' \
    '    setenv("TMPDIR", dir, 1);' \
    '' \
    '    /* Exec the real binary */' \
    '    argv[0] = bin_path;' \
    '    execv(bin_path, argv);' \
    '' \
    '    /* If we get here, exec failed */' \
    '    perror("execv");' \
    '    return 1;' \
    '}' \
    > /build/wrapper.c && \
    gcc -static -o /build/kindle-hid-passthrough /build/wrapper.c && \
    strip /build/kindle-hid-passthrough

# Output:
# /build/kindle-hid-passthrough     - C wrapper (entry point)
# /build/kindle-hid-passthrough.bin - Nuitka Python binary
# /build/libsyscall_wrapper.so      - Syscall compatibility shim
